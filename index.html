<!DOCTYPE html>
<html lang="en">
  <!-- This is a comment -->
<head>
  <meta charset="UTF-8" />
  <title>Russian Cell</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <style>
    :root{
      --header-h: 44px;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);

      --card-w: 80px;
      --card-h: 116px;
      --stack-gap: 24px;
      --col-gap: 8px;
      --radius: 6px;

      /*
       * Keep card-back hues outside all face hue families.
       * Preserve strong luminance separation so back vs face is unmistakable.
       */
      --card-back-stripe-dark: #1a237e;
      --card-back-stripe-light: #283593;
      --card-back-border: #eee;

      --face-spade-light: #cfe3ff;
      --face-heart-light: #ffd0d0;
      --face-diamond-light: #ffe7b8;
      --face-club-light: #d6f5df;

      --face-spade-dark: #1f3a5a;
      --face-heart-dark: #7a0b0b;
      --face-diamond-dark: #8a5a00;
      --face-club-dark: #0b4d22;

      --face-spade-high-contrast: #0A3A8A;
      --face-heart-high-contrast: #B71C1C;
      --face-diamond-high-contrast: #FFD54F;
      --face-club-high-contrast: #00695C;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #205c36;
      color: #fff;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      overflow-y: auto;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      user-select: none;
      -webkit-user-select: none;
      touch-action: auto;
    }
    header {
      flex-shrink: 0; 
      display:flex; justify-content:space-between; align-items:center; 
      padding: calc(6px + var(--safe-top)) calc(12px + var(--safe-right)) 6px calc(12px + var(--safe-left));
      background: rgba(0,0,0,0.25);
}
    header h1 { margin: 0; font-weight: 700; font-size: 16px; letter-spacing: 0.5px;}

    .controls { display:flex; gap:8px; }
    #menuToggle {
      display: none;
      background: #e0e0e0;
      color: #222;
      min-width: 40px;
      padding: 6px 10px;
      font-size: 18px;
      line-height: 1;
    }
    button {
      border: none; border-radius: 4px; padding: 6px 12px; 
      font-weight: 600; font-size: 12px; cursor: pointer;
      background: #e0e0e0; color: #333; box-shadow: 0 2px 2px rgba(0,0,0,0.2);
    }
    button:active { transform: translateY(1px); }
    button#autoBtn { background: #ffda2b; color: #000; }
    button#hintBtn { background: #e1bee7; color: #4a148c; }
    button#giveUpBtn { background: #ef9a9a; color: #b71c1c; }

    #menuToggle:focus-visible,
    .controls button:focus-visible,
    .controls select:focus-visible,
    .controls input:focus-visible {
      outline: 3px solid #ffda2b;
      outline-offset: 2px;
    }

    .app {
      flex: 1 1 auto;
      min-height: 0;
 
      display: flex; flex-direction: column; 
      padding: 8px calc(4px + var(--safe-right)) calc(44px + var(--safe-bottom)) calc(4px + var(--safe-left));
      width: 100%;
      overflow-y: auto;
      overflow-x: hidden;
    }

    .app-version {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 2px calc(8px + var(--safe-right)) calc(2px + var(--safe-bottom)) calc(8px + var(--safe-left));
      font-size: 11px;
      line-height: 1.2;
      opacity: 0.65;
      text-align: center;
      pointer-events: none;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.24), rgba(0, 0, 0, 0));
      z-index: 20;
    }


    .top-section { 
      display: flex; justify-content: center; gap: 12px; 
      margin-bottom: 8px; flex-shrink: 0;
    }
    .zone-title { 
      text-align:center; font-size: 9px; text-transform: uppercase; 
      opacity: .5; margin-bottom: 2px;
    }

    .foundations-row, .hand-row { display:flex; gap: 4px; }
    
    .zone-tableau {
        flex-grow: 1; position: relative;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .tableau-row { 
      display:flex; gap: var(--col-gap); justify-content:center; 
      height: 100%; padding-top: 4px;
    }

    .pile, .foundation, .hand-slot {
      width: var(--card-w);
      min-height: var(--card-h);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: var(--radius);
      position: relative;
      background: rgba(0,0,0,0.1);
      transition: width 0.1s, height 0.1s;
    }
    
    /* Card Styles */
    .card {
      position: absolute;
      width: var(--card-w); height: var(--card-h);
      border-radius: var(--radius);
      background: #fdfbf7;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.4);
      cursor: grab;
      border: 1px solid #bbb;
      z-index: 10;
      transition: transform 0.1s;
      touch-action: none;
    }
    .card:active { transform: scale(0.96); }
    .card.back {
      background:
        repeating-linear-gradient(45deg, var(--card-back-a), var(--card-back-a) 5px, var(--card-back-b) 5px, var(--card-back-b) 10px);
      border: 1px solid var(--card-back-border);
      position: absolute;
      overflow: hidden;
    }
    .card.back::after {
      content: "";
      position: absolute;
      inset: 8px;
      border-radius: calc(var(--radius) - 1px);
      border: 1px solid var(--card-back-accent);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
      background:
        radial-gradient(circle at center, var(--card-back-accent) 0 12%, transparent 13% 100%);
      opacity: 0.8;
      pointer-events: none;
    }
    
    .val-tl { 
      position: absolute; top: 4px; left: 6px; 
      font-size: clamp(14px, calc(var(--card-w) * 0.25), 20px); 
      font-weight: 700; line-height: 1;
    }
    .suit-tr { 
      position: absolute; top: 4px; right: 6px; 
      font-size: clamp(14px, calc(var(--card-w) * 0.25), 20px); 
      line-height: 1;
    }
    .val-center { 
      position: absolute; top: 55%; left: 50%; 
      transform: translate(-50%, -50%); 
      font-size: calc(var(--card-w) * 0.7); 
      font-weight: 800;
      letter-spacing: -2px;
      opacity: 1; 
      pointer-events: none;
    }
    
    .card.dragging { opacity: 0; } 
    .drag-over { background: rgba(255, 218, 43, 0.4); border-color: #ffda2b; box-shadow: 0 0 8px #ffda2b; }
    .selected { outline: 3px solid #ffda2b; z-index: 100 !important; }

    @keyframes pulse-pink {
      0% { box-shadow: 0 0 0 0 rgba(236, 64, 122, 0.7); border-color: #ec407a; }
      70% { box-shadow: 0 0 0 10px rgba(236, 64, 122, 0); border-color: #ec407a; }
      100% { box-shadow: 0 0 0 0 rgba(236, 64, 122, 0); border-color: #ec407a; }
    }
    .hint-source { animation: pulse-pink 1.5s infinite; z-index: 1000 !important; }
    .hint-target { border: 2px solid #ec407a; background: rgba(236, 64, 122, 0.2); }

    #drag-ghost {
      position: fixed; pointer-events: none; z-index: 9999;
      opacity: 0.95; transform: scale(1.05);
      box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
      display: none;
    }

    /* MODAL STYLES */
    .modal-overlay {
      position: fixed; top:0; left:0; width:100%; height:100%;
      background: rgba(0,0,0,0.6);
      display: flex; justify-content: center; align-items: center;
      z-index: 10000;
      opacity: 0; pointer-events: none; transition: opacity 0.3s;
    }
    .modal-overlay.active { opacity: 1; pointer-events: auto; }
    .modal-box {
      background: white; color: #333;
      padding: 30px; border-radius: 12px;
      text-align: center; max-width: 300px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }
    .modal-box h2 { margin-top: 0; color: #205c36; }
    .modal-actions { margin-top: 20px; display: flex; gap: 10px; justify-content: center; }
    .modal-actions button { background: #205c36; color: white; padding: 10px 20px; font-size: 14px; }

    .run-stats {
      display: flex;
      justify-content: center;
      gap: 12px;
      font-size: 12px;
      padding: 4px 8px;
      background: rgba(0,0,0,0.2);
      border-top: 1px solid rgba(255,255,255,0.1);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .run-stats span { opacity: 0.95; }

    .stats-grid {
      text-align: left;
      margin-top: 10px;
      display: grid;
      grid-template-columns: auto auto;
      gap: 6px 16px;
      font-size: 14px;
    }

    .stats-grid strong { text-align: right; }
    
    @media (prefers-reduced-motion: reduce){
      * { animation-duration: 0.001ms !important; animation-iteration-count: 1 !important; transition-duration: 0.001ms !important; }
      .confetti { display: none !important; }
    }

    /* Confetti */
    .confetti {
      position: absolute; width: 10px; height: 10px;
      background: #f00;
      animation: fall linear forwards;
    }
    @keyframes fall { to { transform: translateY(100vh) rotate(720deg); } }
    @supports (height: 100dvh){
      @keyframes fall { to { transform: translateY(100dvh) rotate(720deg); } }
    }
  
    /* Suit background color accessibility toggle */
    :root{
      --suit-bg-spades: #e3f2fd;   /* light blue */
      --suit-bg-hearts: #ffebee;   /* light red/pink */
      --suit-bg-diamonds: #fff8e1; /* light amber */
      --suit-bg-clubs: #e8f5e9;    /* light green */
    }
    /* Slightly smaller label on narrow screens */

  
/* Suit style control */
    .suit-style-label{
      font-size: 12px;
      font-weight: 700;
      opacity: .9;
      align-self: center;
      margin-left: 2px;
      margin-right: 2px;
      white-space: nowrap;
    }
    #suitStyleSelect{
      height: 28px;
      border-radius: 4px;
      border: 1px solid rgba(0,0,0,0.25);
      padding: 0 8px;
      font-weight: 700;
      font-size: 12px;
      background: #e0e0e0;
      color: #222;
      box-shadow: 0 2px 2px rgba(0,0,0,0.2);
      max-width: 160px;
    }
    #suitStyleSelect:active{ transform: translateY(1px); }

    @media (max-width: 420px){
      .suit-style-label{ display:none; }
      .dblclick-foundation-label{ display:inline-block; font-size: 11px; }
      #suitStyleSelect{ max-width: 140px; padding: 0 6px; }
    }

    /* ==============================
       Suit Distinction Styles
       Applies only to face-up cards: .card.face
       Suit class names: .suit-spades/.suit-hearts/.suit-diamonds/.suit-clubs
       ============================== */
    :root{
      --traditional-black: #111111;
      --traditional-red: #c62828;
      --hc-spade: #0A3A8A;
      --hc-heart: #B71C1C;
      --hc-diamond: #FFD54F;
      --hc-club: #00695C;
      --card-back-a: #2f3346;
      --card-back-b: #1f2434;
      --card-back-border: #d8dae2;
      --card-back-accent: rgba(245, 246, 255, 0.25);
    }

    body.suit-style-normal .card.face{ background: #fff; }

    /* A) Traditional red/black backgrounds */
    body.suit-style-color .card.face.suit-spades,
    body.suit-style-color .card.face.suit-clubs{ background: #f0f0f0; }
    body.suit-style-color .card.face.suit-hearts,
    body.suit-style-color .card.face.suit-diamonds{ background: #ffe0e0; }

    /* B) Four-color pips/ranks on white cards */
    body.suit-style-multicolor .card.face{ background: #fff; }
    body.suit-style-multicolor .card.face.suit-spades{ color: var(--hc-spade) !important; }
    body.suit-style-multicolor .card.face.suit-hearts{ color: var(--hc-heart) !important; }
    body.suit-style-multicolor .card.face.suit-diamonds{ color: #b26a00 !important; }
    body.suit-style-multicolor .card.face.suit-clubs{ color: var(--hc-club) !important; }

    /* Shared watermark/pattern infrastructure */
    body.suit-style-watermark .card.face,
    body.suit-style-watermark-hc .card.face,
    body.suit-style-pattern .card.face,
    body.suit-style-pattern-hc .card.face{
      overflow: hidden;
      background-color: #fff;
    }
    body.suit-style-watermark .card.face::after,
    body.suit-style-watermark-hc .card.face::after,
    body.suit-style-pattern .card.face::after,
    body.suit-style-pattern-hc .card.face::after{
      content: attr(data-suitglyph);
      position:absolute;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: calc(var(--card-w) * 1.35);
      font-weight: 900;
      opacity: 0.18;
      transform: translateY(6px);
      pointer-events:none;
    }

    /* C) Watermark (traditional colors, no tinted background) */
    body.suit-style-watermark .card.face.suit-spades,
    body.suit-style-watermark .card.face.suit-clubs{ color: var(--traditional-black) !important; }
    body.suit-style-watermark .card.face.suit-hearts,
    body.suit-style-watermark .card.face.suit-diamonds{ color: var(--traditional-red) !important; }
    body.suit-style-watermark .card.face.suit-spades::after,
    body.suit-style-watermark .card.face.suit-clubs::after{ color: var(--traditional-black); }
    body.suit-style-watermark .card.face.suit-hearts::after,
    body.suit-style-watermark .card.face.suit-diamonds::after{ color: var(--traditional-red); }

    /* D) Watermark high-contrast colors */
    body.suit-style-watermark-hc .card.face.suit-spades{ color: var(--hc-spade) !important; }
    body.suit-style-watermark-hc .card.face.suit-hearts{ color: var(--hc-heart) !important; }
    body.suit-style-watermark-hc .card.face.suit-diamonds{ color: #b26a00 !important; }
    body.suit-style-watermark-hc .card.face.suit-clubs{ color: var(--hc-club) !important; }
    body.suit-style-watermark-hc .card.face.suit-spades::after{ color: var(--hc-spade); }
    body.suit-style-watermark-hc .card.face.suit-hearts::after{ color: var(--hc-heart); }
    body.suit-style-watermark-hc .card.face.suit-diamonds::after{ color: #b26a00; }
    body.suit-style-watermark-hc .card.face.suit-clubs::after{ color: var(--hc-club); }

    /* E) Traditional pattern overlays */
    body.suit-style-pattern .card.face.suit-spades,
    body.suit-style-pattern .card.face.suit-clubs{ color: var(--traditional-black) !important; }
    body.suit-style-pattern .card.face.suit-hearts,
    body.suit-style-pattern .card.face.suit-diamonds{ color: var(--traditional-red) !important; }
    body.suit-style-pattern .card.face.suit-spades::after,
    body.suit-style-pattern .card.face.suit-clubs::after{ color: rgba(17,17,17,0.35); }
    body.suit-style-pattern .card.face.suit-hearts::after,
    body.suit-style-pattern .card.face.suit-diamonds::after{ color: rgba(198,40,40,0.35); }
    body.suit-style-pattern .card.face.suit-spades{
      background-image: repeating-linear-gradient(135deg, rgba(17,17,17,0.12), rgba(17,17,17,0.12) 6px, transparent 6px, transparent 12px);
    }
    body.suit-style-pattern .card.face.suit-hearts{
      background-image:
        radial-gradient(circle at 6px 6px, rgba(198,40,40,0.15) 2px, transparent 3px),
        radial-gradient(circle at 16px 16px, rgba(198,40,40,0.15) 2px, transparent 3px);
      background-size: 20px 20px;
    }
    body.suit-style-pattern .card.face.suit-diamonds{
      background-image:
        repeating-linear-gradient(45deg, rgba(198,40,40,0.14), rgba(198,40,40,0.14) 3px, transparent 3px, transparent 9px),
        repeating-linear-gradient(-45deg, rgba(198,40,40,0.08), rgba(198,40,40,0.08) 3px, transparent 3px, transparent 9px);
    }
    body.suit-style-pattern .card.face.suit-clubs{
      background-image:
        repeating-linear-gradient(0deg, rgba(17,17,17,0.12), rgba(17,17,17,0.12) 2px, transparent 2px, transparent 10px),
        repeating-linear-gradient(90deg, rgba(17,17,17,0.08), rgba(17,17,17,0.08) 2px, transparent 2px, transparent 10px);
    }

    /* F) High-contrast pattern overlays */
    body.suit-style-pattern-hc .card.face.suit-spades{ color: var(--hc-spade) !important; }
    body.suit-style-pattern-hc .card.face.suit-hearts{ color: var(--hc-heart) !important; }
    body.suit-style-pattern-hc .card.face.suit-diamonds{ color: #b26a00 !important; }
    body.suit-style-pattern-hc .card.face.suit-clubs{ color: var(--hc-club) !important; }
    body.suit-style-pattern-hc .card.face.suit-spades::after{ color: rgba(10,58,138,0.35); }
    body.suit-style-pattern-hc .card.face.suit-hearts::after{ color: rgba(183,28,28,0.35); }
    body.suit-style-pattern-hc .card.face.suit-diamonds::after{ color: rgba(178,106,0,0.35); }
    body.suit-style-pattern-hc .card.face.suit-clubs::after{ color: rgba(0,105,92,0.35); }
    body.suit-style-pattern-hc .card.face.suit-spades{
      background-image: repeating-linear-gradient(135deg, rgba(10,58,138,0.14), rgba(10,58,138,0.14) 6px, transparent 6px, transparent 12px);
    }
    body.suit-style-pattern-hc .card.face.suit-hearts{
      background-image:
        radial-gradient(circle at 6px 6px, rgba(183,28,28,0.16) 2px, transparent 3px),
        radial-gradient(circle at 16px 16px, rgba(183,28,28,0.16) 2px, transparent 3px);
      background-size: 20px 20px;
    }
    body.suit-style-pattern-hc .card.face.suit-diamonds{
      background-image:
        repeating-linear-gradient(45deg, rgba(178,106,0,0.14), rgba(178,106,0,0.14) 3px, transparent 3px, transparent 9px),
        repeating-linear-gradient(-45deg, rgba(178,106,0,0.10), rgba(178,106,0,0.10) 3px, transparent 3px, transparent 9px);
    }
    body.suit-style-pattern-hc .card.face.suit-clubs{
      background-image:
        repeating-linear-gradient(0deg, rgba(0,105,92,0.14), rgba(0,105,92,0.14) 2px, transparent 2px, transparent 10px),
        repeating-linear-gradient(90deg, rgba(0,105,92,0.09), rgba(0,105,92,0.09) 2px, transparent 2px, transparent 10px);
    }

    /* G) Big Corner Glyphs (max clarity without recolor) */
    body.suit-style-corners .val-tl,
    body.suit-style-cb-corners .val-tl{ font-size: clamp(18px, calc(var(--card-w) * 0.32), 26px); }
    body.suit-style-corners .suit-tr,
    body.suit-style-cb-corners .suit-tr{ font-size: clamp(18px, calc(var(--card-w) * 0.32), 26px); }
    body.suit-style-corners .val-center,
    body.suit-style-cb-corners .val-center{ opacity: 0.35; }

    /* H) High-contrast backgrounds */
    body.suit-style-cb .card.face,
    body.suit-style-cb-corners .card.face{ color:#fff !important; border-color: rgba(255,255,255,.35); }
    body.suit-style-cb .card.face.suit-spades,
    body.suit-style-cb-corners .card.face.suit-spades{ background: var(--face-spade-high-contrast); }
    body.suit-style-cb .card.face.suit-hearts,
    body.suit-style-cb-corners .card.face.suit-hearts{ background: var(--face-heart-high-contrast); }
    body.suit-style-cb .card.face.suit-diamonds,
    body.suit-style-cb-corners .card.face.suit-diamonds{ background: var(--face-diamond-high-contrast); color:#111 !important; border-color: rgba(0,0,0,.5); }
    body.suit-style-cb .card.face.suit-clubs,
    body.suit-style-cb-corners .card.face.suit-clubs{ background: var(--face-club-high-contrast); }
    body.suit-style-cb .card.face:not(.suit-diamonds) .val-tl,
    body.suit-style-cb .card.face:not(.suit-diamonds) .suit-tr,
    body.suit-style-cb-corners .card.face:not(.suit-diamonds) .val-tl,
    body.suit-style-cb-corners .card.face:not(.suit-diamonds) .suit-tr{ text-shadow: 0 1px 1px rgba(0,0,0,0.4); }
    body.suit-style-cb .card.face.suit-diamonds .val-tl,
    body.suit-style-cb .card.face.suit-diamonds .suit-tr,
    body.suit-style-cb-corners .card.face.suit-diamonds .val-tl,
    body.suit-style-cb-corners .card.face.suit-diamonds .suit-tr{ text-shadow: 0 1px 0 rgba(255,255,255,0.35); }
    body.suit-style-cb,
    body.suit-style-cb-corners {
      --card-back-a: #4b2d6b;
      --card-back-b: #311b4a;
      --card-back-border: #e8ddf7;
      --card-back-accent: rgba(255,255,255,0.32);
    }

    @media (prefers-color-scheme: dark){
      body{ background: #184b2d; }
      header{ background: rgba(0,0,0,0.4); }
      .run-stats{ background: rgba(0,0,0,0.35); }
      .modal-box{ background: #f4f4f4; }
    }

  
/* --- Responsive header + mobile menu --- */
header{
  flex-wrap: nowrap;
  gap: 8px;
}
header .header-main{
  display: flex;
  align-items: center;
  gap: 8px;
}
header .controls{
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  min-width: 0;
}
header .controls > *{ flex: 0 0 auto; }

#menuToggle{
  display: none;
  min-width: 34px;
  height: 30px;
  padding: 0;
  font-size: 16px;
  line-height: 1;
}

@media (max-width: 520px){
  header{
    flex-wrap: wrap;
    align-items: flex-start;
    row-gap: 6px;
    padding: calc(6px + var(--safe-top)) calc(8px + var(--safe-right)) 6px calc(8px + var(--safe-left));
  }
  header .header-main{
    width: 100%;
    justify-content: space-between;
  }
  header h1{ font-size: 14px; margin-right: 6px; }
  #menuToggle{ display: inline-flex; align-items: center; justify-content: center; }

  header .controls{
    flex: 1 1 100%;
    overflow: hidden;
    max-height: 0;
    opacity: 0;
    visibility: hidden;
    transform: translateY(-4px);
    pointer-events: none;
    transition: max-height 0.2s ease, opacity 0.2s ease, transform 0.2s ease, visibility 0s linear 0.2s;
  }
  header.menu-open .controls{
    max-height: 260px;
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
    pointer-events: auto;
    transition-delay: 0s;
  }
  header h1{ flex: 1 1 120px; font-size: 14px; margin-right: 6px; }
  #menuToggle {
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  header .controls{ flex: 1 1 100%; }
  header .controls button,
  header .controls select{
    height: 28px;
    font-size: 12px;
    padding: 0 8px;
    max-width: 100%;
  }
}


/* Rules Modal */
.rules-modal{
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}
.rules-modal.hidden{ display: none; }
.rules-content{
  background: #ffffff;
  color: #111;
  padding: 20px;
  border-radius: 8px;
  max-width: 90%;
  width: 420px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.4);
}
.rules-content h2{ margin-top: 0; }
.rules-content button{
  margin-top: 12px;
  padding: 6px 12px;
  font-weight: bold;
}


/* Rules modal formatting */
.rules-content{
  max-height: min(80vh, 620px);
  overflow: auto;
}
.rules-content h2{ margin: 0 0 10px; }
.rules-content h3{
  margin: 14px 0 6px;
  font-size: 14px;
}
.rules-content p{
  margin: 6px 0;
  line-height: 1.35;
}
.rules-content ul{ margin: 6px 0 8px 18px; }
.rules-content ul.examples{ margin-top: 4px; }
.rules-content .suit-red{ color: #c62828; font-weight: 700; }
.rules-content .suit-black{ color: #111; font-weight: 700; }

</style>
</head>
<body class="suit-style-normal">
  <header>
    <div class="header-main">
      <h1>Russian Cell</h1>
      <button id="menuToggle" type="button" aria-label="Open menu" aria-expanded="false" aria-controls="headerControls">☰</button>
    </div>
    <div class="controls" id="headerControls">
      <button id="hintBtn" onclick="showHint()">Hint</button>
      
      <label class="suit-style-label" for="suitStyleSelect">Suit Style:</label>
      <select id="suitStyleSelect" title="Choose suit distinction style">
        <option value="normal">Normal (Traditional)</option>
        <option value="color">Red/Black Backgrounds</option>
        <option value="multicolor">Four-Color Symbols</option>
        <option value="watermark">Traditional Watermark</option>
        <option value="watermark-hc">High Contrast Watermark</option>
        <option value="pattern">Traditional Patterns</option>
        <option value="pattern-hc">High Contrast Patterns</option>
        <option value="corners">Big Corner Glyphs</option>
        <option value="cb">High Contrast Backgrounds</option>
        <option value="cb-corners">High Contrast + Big Corner Glyphs</option>
      </select>

      <label class="suit-style-label dblclick-foundation-label" for="doubleClickFoundationToggle">Double-click to Foundation</label>
      <input id="doubleClickFoundationToggle" type="checkbox" title="Double-click a top card or free-cell card to move it to a valid foundation" />

      <label class="suit-style-label" for="dealVariantSelect">Free Cells</label>
      <select id="dealVariantSelect" title="Choose how many free cells are available at the start">
        <option value="cells0">0</option>
        <option value="cells1">1</option>
        <option value="cells2">2</option>
        <option value="cells3" selected>3</option>
        <option value="cells4">4</option>
      </select>


      
      <button id="rulesBtn" title="View rules">Rules</button>
      <button id="statsBtn" title="View stats">Stats</button>
<button id="autoBtn">Auto</button>
      <button id="giveUpBtn">Give Up</button>
      <button id="undoBtn">Undo</button>
    </div>
  </header>

  <div class="run-stats" id="runStatsBar">
    <span id="moveCountStat">Moves: 0</span>
    <span id="elapsedTimeStat">Time: 00:00</span>
    <span id="undoCountStat">Undos: 0</span>
  </div>

  <div class="app">
    <div class="top-section">
      <div class="zone-found">
        <div class="zone-title">Foundations</div>
        <div class="foundations-row">
          <div class="foundation" data-id="0"></div>
          <div class="foundation" data-id="1"></div>
          <div class="foundation" data-id="2"></div>
          <div class="foundation" data-id="3"></div>
        </div>
      </div>

      <div class="zone-hand">
        <div class="zone-title">Cells</div>
        <div class="hand-row">
          <div class="hand-slot" data-id="0"></div>
          <div class="hand-slot" data-id="1"></div>
          <div class="hand-slot" data-id="2"></div>
          <div class="hand-slot" data-id="3"></div>
        </div>
      </div>
    </div>

    <div class="zone-tableau">
      <div class="tableau-row" id="tableau">
        <div class="pile" data-id="0"></div>
        <div class="pile" data-id="1"></div>
        <div class="pile" data-id="2"></div>
        <div class="pile" data-id="3"></div>
        <div class="pile" data-id="4"></div>
        <div class="pile" data-id="5"></div>
        <div class="pile" data-id="6"></div>
      </div>
    </div>
  </div>

  <footer class="app-version">Version <span id="appVersion"></span></footer>

  <div id="drag-ghost"></div>

  <div id="modalWin" class="modal-overlay">
    <div class="modal-box">
      <h2>Victory!</h2>
      <p>You have conquered the cards.</p>
      <div class="modal-actions">
        <button onclick="start()">Play Again</button>
      </div>
    </div>
  </div>

  <div id="modalLose" class="modal-overlay">
    <div class="modal-box">
      <h2 style="color:#b71c1c">Out of Moves</h2>
      <p>The cards have won this round.</p>
      <div class="modal-actions">
        <button onclick="undo()">Undo</button>
        <button onclick="start()">New Game</button>
      </div>
    </div>
  </div>

  <div id="modalStats" class="modal-overlay">
    <div class="modal-box">
      <h2>Stats</h2>
      <div class="stats-grid" id="statsGrid"></div>
      <div class="modal-actions">
        <button id="resetStatsBtn">Reset Stats</button>
        <button id="closeStatsBtn">Close</button>
      </div>
    </div>
  </div>

<script>
const suits = ["♠","♥","♦","♣"];
const ranks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const suitColors = { "♠":"#111111", "♥":"#c62828", "♦":"#c62828", "♣":"#111111" };

const suitClass = { "♠":"spades", "♥":"hearts", "♦":"diamonds", "♣":"clubs" };

const SUIT_STYLE_KEY = "rs_suitStyle_v1";
const GAME_STATE_KEY = "rs_gameState_v1";
const STATS_HISTORY_KEY = "rs_statsHistory_v1";
const DBL_CLICK_FOUNDATION_KEY = "rs_dblClickFoundation_v1";
const DEAL_VARIANT_KEY = "rs_dealVariant_v1";
const MAX_STATS_HISTORY = 100;
const APP_VERSION = "v0.2.3";

const DEAL_VARIANTS = {
  cells0: {
    freeCells: 0,
    columns: [
      { total: 7, faceDown: 0 },
      { total: 7, faceDown: 1 },
      { total: 7, faceDown: 2 },
      { total: 7, faceDown: 3 },
      { total: 8, faceDown: 4 },
      { total: 8, faceDown: 5 },
      { total: 8, faceDown: 6 }
    ]
  },
  cells1: {
    freeCells: 1,
    columns: [
      { total: 7, faceDown: 0 },
      { total: 7, faceDown: 1 },
      { total: 7, faceDown: 2 },
      { total: 7, faceDown: 3 },
      { total: 7, faceDown: 4 },
      { total: 8, faceDown: 5 },
      { total: 8, faceDown: 6 }
    ]
  },
  cells2: {
    freeCells: 2,
    columns: [
      { total: 7, faceDown: 0 },
      { total: 7, faceDown: 1 },
      { total: 7, faceDown: 2 },
      { total: 7, faceDown: 3 },
      { total: 7, faceDown: 4 },
      { total: 7, faceDown: 5 },
      { total: 8, faceDown: 6 }
    ]
  },
  cells3: {
    freeCells: 3,
    columns: [
      { total: 7, faceDown: 0 },
      { total: 7, faceDown: 1 },
      { total: 7, faceDown: 2 },
      { total: 7, faceDown: 3 },
      { total: 7, faceDown: 4 },
      { total: 7, faceDown: 5 },
      { total: 7, faceDown: 6 }
    ]
  },
  cells4: {
    freeCells: 4,
    columns: [
      { total: 6, faceDown: 0 },
      { total: 7, faceDown: 1 },
      { total: 7, faceDown: 2 },
      { total: 7, faceDown: 3 },
      { total: 7, faceDown: 4 },
      { total: 7, faceDown: 5 },
      { total: 7, faceDown: 6 }
    ]
  }
};

let currentDealVariantKey = "cells3";

function getDealVariantConfig(variantKey){
  return DEAL_VARIANTS[variantKey] || DEAL_VARIANTS.cells3;
}

function getCurrentDealConfig(){
  return getDealVariantConfig(currentDealVariantKey);
}

function loadDealVariantPreference(){
  try {
    const saved = localStorage.getItem(DEAL_VARIANT_KEY);
    if(saved && DEAL_VARIANTS[saved]) currentDealVariantKey = saved;
  } catch(e) {}
}

function applyDealVariant(variantKey){
  if(!DEAL_VARIANTS[variantKey]) return;
  currentDealVariantKey = variantKey;
  const sel = document.getElementById("dealVariantSelect");
  if(sel && sel.value !== variantKey) sel.value = variantKey;
  try { localStorage.setItem(DEAL_VARIANT_KEY, variantKey); } catch(e) {}
  scheduleFit();
}

function initDealVariantUI(){
  loadDealVariantPreference();
  const sel = document.getElementById("dealVariantSelect");
  if(!sel) return;
  sel.value = currentDealVariantKey;
  sel.addEventListener("change", () => {
    applyDealVariant(sel.value);
    start();
  });
}
function applySuitStyle(style){
  const clsPrefix = "suit-style-";
  // remove existing suit-style-* classes
  document.body.className = document.body.className
    .split(/\s+/)
    .filter(c => c && !c.startsWith(clsPrefix))
    .join(" ");
  document.body.classList.add(clsPrefix + style);

  const sel = document.getElementById("suitStyleSelect");
  if(sel && sel.value !== style) sel.value = style;

  try { localStorage.setItem(SUIT_STYLE_KEY, style); } catch(e) {}
  scheduleFit();
}

function loadSuitStyle(){
  let style = "normal";
  try { style = localStorage.getItem(SUIT_STYLE_KEY) || "normal"; } catch(e) {}

  // Map removed legacy styles to closest current options.
  if(style === "dark") style = "cb";
  if(style === "border") style = "color";

  const allowed = new Set(["normal","color","multicolor","watermark","watermark-hc","pattern","pattern-hc","corners","cb","cb-corners"]);
  if(!allowed.has(style)) style = "normal";
  applySuitStyle(style);
}

function initSuitStyleUI(){
  const sel = document.getElementById("suitStyleSelect");
  if(sel){
    sel.addEventListener("change", () => applySuitStyle(sel.value));
  }
  loadSuitStyle();
}

function loadDoubleClickFoundationPreference(){
  try {
    const raw = localStorage.getItem(DBL_CLICK_FOUNDATION_KEY);
    if(raw === null){
      doubleClickToFoundationEnabled = true;
      return;
    }
    doubleClickToFoundationEnabled = raw === "1";
  } catch(e){
    doubleClickToFoundationEnabled = true;
  }
}

function applyDoubleClickFoundationPreference(enabled){
  doubleClickToFoundationEnabled = !!enabled;
  const checkbox = document.getElementById("doubleClickFoundationToggle");
  if(checkbox) checkbox.checked = doubleClickToFoundationEnabled;
  try {
    localStorage.setItem(DBL_CLICK_FOUNDATION_KEY, doubleClickToFoundationEnabled ? "1" : "0");
  } catch(e) {}
}

function initDoubleClickFoundationUI(){
  loadDoubleClickFoundationPreference();
  const checkbox = document.getElementById("doubleClickFoundationToggle");
  if(!checkbox) return;
  checkbox.checked = doubleClickToFoundationEnabled;
  checkbox.addEventListener("change", () => applyDoubleClickFoundationPreference(checkbox.checked));
}

function renderAppVersion(){
  const versionEl = document.getElementById("appVersion");
  if(!versionEl) return;

  const resolvedVersion = (typeof APP_VERSION === "string" ? APP_VERSION.trim() : "");
  versionEl.textContent = resolvedVersion || "v0.0.0";
}

let tableau=[[],[],[],[],[],[],[]];
let foundations=[[],[],[],[]];
let hand=[];
let historyStack=[];
let selected=null;
let moveCount=0;
let undoCount=0;
let elapsedMs=0;
let timerInterval=null;
let lastTickTs=Date.now();
let timerActive=false;
let gameFinished=false;
let runResultRecorded=false;
let doubleClickToFoundationEnabled=true;

const MAX_PERSISTED_HISTORY = 150;

function persistGameState(){
  const persistedHistory = historyStack.slice(-MAX_PERSISTED_HISTORY);
  const snapshot = {
    tableau,
    foundations,
    hand,
    currentDealVariantKey,
    historyStack: persistedHistory,
    moveCount,
    undoCount,
    elapsedMs,
    gameFinished,
    runResultRecorded
  };

  // Browsers have strict localStorage quotas; if persistence fails, trim
  // history snapshots and retry so current progress is never dropped.
  for(let keep = persistedHistory.length; keep >= 0; keep--){
    snapshot.historyStack = keep === 0 ? [] : persistedHistory.slice(-keep);
    try {
      localStorage.setItem(GAME_STATE_KEY, JSON.stringify(snapshot));
      return;
    } catch(e) {}
  }
}

function loadPersistedGameState(){
  try {
    const raw = localStorage.getItem(GAME_STATE_KEY);
    if(!raw) return false;
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.tableau) || !Array.isArray(parsed.foundations) || !Array.isArray(parsed.hand)) return false;
    if(parsed.tableau.length !== 7 || parsed.foundations.length !== 4) return false;

    const persistedVariantKey = parsed.currentDealVariantKey && DEAL_VARIANTS[parsed.currentDealVariantKey]
      ? parsed.currentDealVariantKey
      : (parsed.hand.length >= 0 && parsed.hand.length <= 4 ? `cells${parsed.hand.length}` : "cells3");
    applyDealVariant(persistedVariantKey);

    const expectedFreeCells = getCurrentDealConfig().freeCells;
    if(parsed.hand.length !== expectedFreeCells) return false;

    tableau = parsed.tableau;
    foundations = parsed.foundations;
    hand = parsed.hand;
    historyStack = Array.isArray(parsed.historyStack) ? parsed.historyStack : [];
    moveCount = Number.isFinite(parsed.moveCount) ? parsed.moveCount : 0;
    undoCount = Number.isFinite(parsed.undoCount) ? parsed.undoCount : 0;
    elapsedMs = Number.isFinite(parsed.elapsedMs) ? parsed.elapsedMs : 0;
    gameFinished = !!parsed.gameFinished;
    runResultRecorded = !!parsed.runResultRecorded;
    selected = null;
    return true;
  } catch(e){
    return false;
  }
}


function formatDuration(ms){
  const totalSeconds = Math.floor(ms / 1000);
  const mins = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
  const secs = (totalSeconds % 60).toString().padStart(2, '0');
  return `${mins}:${secs}`;
}

function updateRunStatsUI(){
  const moveEl = document.getElementById('moveCountStat');
  const timeEl = document.getElementById('elapsedTimeStat');
  const undoEl = document.getElementById('undoCountStat');
  if(moveEl) moveEl.textContent = `Moves: ${moveCount}`;
  if(timeEl) timeEl.textContent = `Time: ${formatDuration(elapsedMs)}`;
  if(undoEl) undoEl.textContent = `Undos: ${undoCount}`;
}

function startTimer(){
  if(timerInterval) clearInterval(timerInterval);
  syncTimerPresence();
  timerInterval = setInterval(() => {
    if(!timerActive || gameFinished) return;
    const now = Date.now();
    elapsedMs += now - lastTickTs;
    lastTickTs = now;
    updateRunStatsUI();
    persistGameState();
  }, 1000);
}

function isPlayerPresent(){
  return !document.hidden && document.hasFocus();
}

function syncTimerPresence(){
  const shouldBeActive = !gameFinished && isPlayerPresent();
  if(shouldBeActive){
    lastTickTs = Date.now();
    timerActive = true;
    return;
  }

  if(timerActive){
    const now = Date.now();
    elapsedMs += Math.max(0, now - lastTickTs);
    timerActive = false;
    updateRunStatsUI();
    persistGameState();
  }
}

function resetRunStats(){
  moveCount = 0;
  undoCount = 0;
  elapsedMs = 0;
  gameFinished = false;
  runResultRecorded = false;
  timerActive = false;
  lastTickTs = Date.now();
  updateRunStatsUI();
}

function loadStatsHistory(){
  try {
    const parsed = JSON.parse(localStorage.getItem(STATS_HISTORY_KEY) || '[]');
    return Array.isArray(parsed) ? parsed : [];
  } catch(e){
    return [];
  }
}

function saveStatsHistory(history){
  try {
    localStorage.setItem(STATS_HISTORY_KEY, JSON.stringify(history.slice(-MAX_STATS_HISTORY)));
  } catch(e) {}
}

function recordGameResult(outcome){
  if(gameFinished || runResultRecorded) return;
  syncTimerPresence();
  gameFinished = true;
  runResultRecorded = true;
  const history = loadStatsHistory();
  history.push({ outcome, moveCount, undoCount, elapsedMs, finishedAt: Date.now() });
  saveStatsHistory(history);
  persistGameState();
  renderStatsModal();
}

function computeStats(history){
  const totalGames = history.length;
  const wins = history.filter(g => g.outcome === 'win');
  const winRate = totalGames ? (wins.length / totalGames) * 100 : 0;

  let currentStreak = 0;
  for(let i=history.length - 1; i>=0; i--){
    if(history[i].outcome !== 'win') break;
    currentStreak++;
  }

  let bestStreak = 0;
  let running = 0;
  for(const game of history){
    if(game.outcome === 'win'){
      running++;
      if(running > bestStreak) bestStreak = running;
    } else {
      running = 0;
    }
  }

  const avgMovesOnWins = wins.length ? Math.round(wins.reduce((sum, g) => sum + g.moveCount, 0) / wins.length) : 0;
  const avgTimeOnWins = wins.length ? Math.round(wins.reduce((sum, g) => sum + g.elapsedMs, 0) / wins.length) : 0;

  return { totalGames, winRate, currentStreak, bestStreak, avgMovesOnWins, avgTimeOnWins };
}

function renderStatsModal(){
  const grid = document.getElementById('statsGrid');
  if(!grid) return;
  const stats = computeStats(loadStatsHistory());
  grid.innerHTML = `
    <span>Total games</span><strong>${stats.totalGames}</strong>
    <span>Win rate</span><strong>${stats.winRate.toFixed(1)}%</strong>
    <span>Current streak</span><strong>${stats.currentStreak}</strong>
    <span>Best streak</span><strong>${stats.bestStreak}</strong>
    <span>Avg moves (wins)</span><strong>${stats.avgMovesOnWins}</strong>
    <span>Avg time (wins)</span><strong>${formatDuration(stats.avgTimeOnWins)}</strong>
  `;
}

function makeDeck(){
  const d=[]; for(const s of suits){ for(let r=0;r<ranks.length;r++){ d.push({suit:s,rank:ranks[r],value:r+1,faceUp:true}); } }
  return d;
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} }

function save(){
  // Save snapshot of current state (used as a "pre-move" history entry).
  historyStack.push(JSON.stringify({
    tableau,
    foundations,
    hand,
    currentDealVariantKey,
    moveCount,
    undoCount,
    elapsedMs,
    gameFinished,
    runResultRecorded
  }));
}
function undo(){
  closeModals();
  clearHints();
  // History stores snapshots from BEFORE each committed change.
  // So undo should restore the LAST saved snapshot (top of stack).
  if(historyStack.length > 0){
    const prev = JSON.parse(historyStack.pop());
    tableau = prev.tableau;
    foundations = prev.foundations;
    hand = prev.hand;
    moveCount = Number.isFinite(prev.moveCount) ? prev.moveCount : moveCount;
    undoCount = Number.isFinite(prev.undoCount) ? prev.undoCount : undoCount;
    elapsedMs = Number.isFinite(prev.elapsedMs) ? prev.elapsedMs : elapsedMs;
    gameFinished = typeof prev.gameFinished === 'boolean' ? prev.gameFinished : false;
    runResultRecorded = typeof prev.runResultRecorded === 'boolean' ? prev.runResultRecorded : false;
    selected = null;
    undoCount++;
    lastTickTs = Date.now();
    persistGameState();
    updateRunStatsUI();
    fit(); render();
  }
}

function start(){
  if(hasActiveRunToRecordAsLoss()) recordGameResult('loss');
  closeModals();
  const config = getCurrentDealConfig();
  tableau=[[],[],[],[],[],[],[]]; foundations=[[],[],[],[]]; hand=Array(config.freeCells).fill(null); historyStack=[]; selected=null;
  resetRunStats();
  const deck=makeDeck(); shuffle(deck);
  for(let i=0;i<7;i++){
    const col = config.columns[i];
    for(let d=0;d<col.faceDown;d++){
      const c=deck.pop();
      c.faceUp=false;
      tableau[i].push(c);
    }
    for(let u=0;u<col.total-col.faceDown;u++){
      const c=deck.pop();
      c.faceUp=true;
      tableau[i].push(c);
    }
  }
  for(let k=0;k<hand.length;k++) hand[k]=deck.pop();
  persistGameState();
  startTimer();
  fit();
  render();
}

function canTableau(c,t){return c.suit===t.suit && c.value===t.value-1;}
function canFoundation(c,p){if(!p.length)return c.value===1;return c.suit===p[p.length-1].suit&&c.value===p[p.length-1].value+1;}

function executePileToPile(srcI, j, destI){
  // Prevent dropping onto the same tableau pile (would otherwise orphan the moved cards).
  if(srcI===destI) return false;

  const moving = tableau[srcI].slice(j);
  const destPile = tableau[destI];
  if(!moving.length) return false;
  if(!moving[0].faceUp) return false;

  if(!destPile.length){
    if(moving[0].rank!=="K") return false;
  } else {
    if(!canTableau(moving[0], destPile[destPile.length-1])) return false;
  }

  save();
  moveCount++;
  tableau[srcI] = tableau[srcI].slice(0, j);
  destPile.push(...moving);
  flipTop(srcI);
  persistGameState();
  return true;
}

function executeHandToPile(handIdx, destI){
  const c = hand[handIdx];
  const destPile = tableau[destI];
  if(!destPile.length){ if(c.rank!=="K") return false; }
  else { if(!canTableau(c, destPile[destPile.length-1])) return false; }
  save();
  moveCount++;
  hand[handIdx]=null;
  destPile.push(c);
  persistGameState();
  return true;
}

function tryFoundation(c, srcType, srcIdx, cardIdx){
  for(let f=0; f<4; f++){
    if(canFoundation(c, foundations[f])){
      save();
      moveCount++;
      foundations[f].push(c);
      if(srcType==="pile") { tableau[srcIdx].pop(); flipTop(srcIdx); }
      else if(srcType==="hand") { hand[srcIdx]=null; }
      persistGameState();
      return true;
    }
  }
  return false;
}

function executePileToHand(srcI, handIdx){
  if(hand[handIdx]) return false;
  const p = tableau[srcI];
  if(!p.length) return false;
  save();
  moveCount++;
  hand[handIdx] = p.pop();
  flipTop(srcI);
  persistGameState();
  return true;
}

function moveCardToAnyFoundation(type, idx, cardIdx){
  if(type === 'pile'){
    if(cardIdx !== tableau[idx].length - 1) return false;
    const c = tableau[idx][cardIdx];
    return tryFoundation(c, 'pile', idx, cardIdx);
  }
  if(type === 'hand'){
    const c = hand[idx];
    if(!c) return false;
    return tryFoundation(c, 'hand', idx);
  }
  return false;
}

function moveCardToAnyTableau(type, idx, cardIdx){
  let movingCard;
  if(type === 'pile'){
    if(cardIdx !== tableau[idx].length - 1) return false;
    movingCard = tableau[idx][cardIdx];
  } else if(type === 'hand'){
    movingCard = hand[idx];
    if(!movingCard) return false;
  } else {
    return false;
  }

  // Deterministic target selection policy:
  // 1) Prefer non-empty tableau piles where canTableau(movingCard, topCard) is valid.
  // 2) Only if none exist, allow moving a King to an empty tableau pile.
  // 3) In either case, choose the leftmost valid tableau index.
  let targetIdx = -1;
  for(let t=0; t<7; t++){
    if(type === 'pile' && t === idx) continue;
    const targetPile = tableau[t];
    if(targetPile.length && canTableau(movingCard, targetPile[targetPile.length-1])){
      targetIdx = t;
      break;
    }
  }

  if(targetIdx === -1 && movingCard.rank === 'K'){
    for(let t=0; t<7; t++){
      if(type === 'pile' && t === idx) continue;
      if(!tableau[t].length){
        targetIdx = t;
        break;
      }
    }
  }

  if(targetIdx === -1) return false;
  if(type === 'pile') return executePileToPile(idx, cardIdx, targetIdx);
  return executeHandToPile(idx, targetIdx);
  if(type === 'pile'){
    const srcPile = tableau[idx];
    if(!srcPile.length) return false;
    if(cardIdx < 0 || cardIdx >= srcPile.length) return false;
    if(!srcPile[cardIdx].faceUp) return false;
    for(let destI = 0; destI < 7; destI++){
      if(destI === idx) continue;
      if(executePileToPile(idx, cardIdx, destI)) return true;
    }
    return false;
  }
  if(type === 'hand'){
    if(!hand[idx]) return false;
    for(let destI = 0; destI < 7; destI++){
      if(executeHandToPile(idx, destI)) return true;
    }
    return false;
  }
  return false;
}

function tryAutoMoveFromTap(type, idx, cardIdx){
  return moveCardToAnyFoundation(type, idx, cardIdx) || moveCardToAnyTableau(type, idx, cardIdx);
}

function hasActiveRunToRecordAsLoss(){
  if(gameFinished) return false;
  if(moveCount > 0 || undoCount > 0 || elapsedMs > 0) return true;
  if(historyStack.length > 0) return true;
  return foundations.some(p => p.length > 0);
}

function flipTop(i){
  const p=tableau[i]; 
  if(p.length && !p[p.length-1].faceUp) p[p.length-1].faceUp=true;
}

function autoPlay(){
  clearHints();
  let moved = true; let loops = 0;
  while(moved && loops < 50){ 
    moved = false; loops++;
    for(let h=0; h<hand.length; h++){
      if(hand[h] && tryFoundation(hand[h], "hand", h)) { moved=true; break; }
    }
    if(moved) continue;
    for(let t=0; t<7; t++){
      const p = tableau[t];
      if(p.length){
        const c = p[p.length-1];
        if(tryFoundation(c, "pile", t, p.length-1)){ moved=true; break; }
      }
    }
  }
  if(loops>0) render();
  checkGameState();
}

function clearHints(){
  document.querySelectorAll('.hint-source, .hint-target').forEach(el => {
    el.classList.remove('hint-source'); el.classList.remove('hint-target');
  });
}

function showHint(){
  clearHints();
  if(findAnyMove(true)) return;
  alert("No suggestions found.");
}

function canFinalizeLoss(){
  return historyStack.length === 0;
}

/* --- GAME STATE CHECKS --- */
function checkGameState(){
  if(isWin()){
    celebrate();
    recordGameResult('win');
    document.getElementById('modalWin').classList.add('active');
  } else {
    // Check for loss (no moves possible)
    if(!findAnyMove(false)){
      if(canFinalizeLoss()) recordGameResult('loss');
      document.getElementById('modalLose').classList.add('active');
    }
  }
}

function findAnyMove(highlight){
  // Returns true if a move exists. If highlight=true, it highlights it.
  
  // 1. Hand -> Foundation
  for(let i=0; i<hand.length; i++){
    if(hand[i]){
      for(let f=0; f<4; f++){
        if(canFoundation(hand[i], foundations[f])){
          if(highlight) { highlightHand(i, 'source'); highlightFoundation(f, 'target'); }
          return true;
        }
      }
    }
  }
  // 2. Pile Top -> Foundation
  for(let i=0; i<7; i++){
    if(tableau[i].length){
      const c = tableau[i][tableau[i].length-1];
      for(let f=0; f<4; f++){
        if(canFoundation(c, foundations[f])){
          if(highlight) { highlightPileCard(i, tableau[i].length-1, 'source'); highlightFoundation(f, 'target'); }
          return true;
        }
      }
    }
  }
  // 3. Hand -> Tableau
  for(let i=0; i<hand.length; i++){
    if(hand[i]){
      for(let t=0; t<7; t++){
        const tp = tableau[t];
        if(!tp.length){ 
          if(hand[i].rank==='K'){ 
            if(highlight) { highlightHand(i,'source'); highlightPile(t,'target'); }
            return true; 
          } 
        }
        else if(canTableau(hand[i], tp[tp.length-1])){ 
          if(highlight) { highlightHand(i,'source'); highlightPileCard(t, tp.length-1, 'target'); }
          return true; 
        }
      }
    }
  }
  // 4. Pile -> Tableau (Deep moves allowed)
  // Prefer stronger progress first; fallback can include king-to-empty only when it reveals cards (j > 0).
  const findPileToTableauMove = (allowBaseKingToEmpty) => {
    for(let i=0; i<7; i++){
      const p = tableau[i];
      for(let j=0; j<p.length; j++){
        if(!p[j].faceUp) continue;
        const c = p[j];
        for(let t=0; t<7; t++){
          if(i===t) continue;
          const tp = tableau[t];
          if(!tp.length){
            const movingKingToEmpty = c.rank === 'K' && j > 0 && (allowBaseKingToEmpty || j > 0);
            if(movingKingToEmpty){
              if(highlight) { highlightPileCard(i,j,'source'); highlightPile(t,'target'); }
              return true;
            }
          }
          else if(canTableau(c, tp[tp.length-1])){
            if(highlight) { highlightPileCard(i,j,'source'); highlightPileCard(t, tp.length-1, 'target'); }
            return true;
          }
        }
      }
    }
    return false;
  };

  // Pass 1: stronger progress only (no base king -> empty pile moves).
  if(findPileToTableauMove(false)) return true;
  // Pass 2: fallback still excludes j === 0 king-to-empty shuffles.
  if(findPileToTableauMove(true)) return true;
  // 5. Pile Top -> Hand (Only if Hand slot empty)
  for(let h=0; h<hand.length; h++){
      if(!hand[h]){
          // Can we move a top card to hand? Yes.
          // Is it useful? Maybe to uncover a card. Any visible top card on a pile > 1 deep is a candidate.
          for(let i=0; i<7; i++){
              if(tableau[i].length > 1){ // Only valid if revealing something or saving a card
                  if(highlight) { highlightPileCard(i, tableau[i].length-1, 'source'); highlightHand(h, 'target'); }
                  return true;
              }
          }
      }
  }
  
  return false;
}

function isWin(){
  return foundations.reduce((a,b)=>a+b.length,0)===52;
}

function celebrate(){
  // Confetti logic
  for(let i=0; i<50; i++){
    const c = document.createElement('div');
    c.className = 'confetti';
    c.style.left = Math.random()*100 + 'vw';
    c.style.animationDuration = (Math.random()*2 + 2) + 's';
    c.style.background = `hsl(${Math.random()*360}, 100%, 50%)`;
    document.body.appendChild(c);
    setTimeout(()=>c.remove(), 4000);
  }
}

function closeModals(){
  document.querySelectorAll('.modal-overlay').forEach(el => el.classList.remove('active'));
}

/* --- HIGHLIGHTERS --- */
function highlightHand(idx, type){ 
  const el = document.querySelector(`.hand-slot[data-id="${idx}"] .card`); if(el) el.classList.add('hint-'+type); 
  else if(type==='target') document.querySelector(`.hand-slot[data-id="${idx}"]`).classList.add('hint-'+type);
}
function highlightFoundation(idx, type){ 
  const el = document.querySelector(`.foundation[data-id="${idx}"]`); if(el) el.classList.add('hint-'+type); 
}
function highlightPile(idx, type){ 
  const el = document.querySelector(`.pile[data-id="${idx}"]`); if(el) el.classList.add('hint-'+type); 
}
function highlightPileCard(pileIdx, cardIdx, type){ 
  const pile = document.querySelector(`.pile[data-id="${pileIdx}"]`);
  const cards = pile.querySelectorAll('.card');
  if(cards[cardIdx]) cards[cardIdx].classList.add('hint-'+type);
}

/* --- INTERACTION --- */
let dragSource = null;
let touchClone = document.getElementById('drag-ghost');
let touchStartCoords = {x:0, y:0};
let isDragGesture = false;
let touchOriginalEl = null;
let lastTap = { ts: 0, type: null, idx: null, cardIdx: null };
const DOUBLE_TAP_WINDOW_MS = 300;
const SINGLE_TAP_DELAY_MS = 220;
let pendingTapClick = null;

function handleDragStart(e, type, idx, cardIdx){
  clearHints();
  if(type === 'pile' && !tableau[idx][cardIdx].faceUp) { e.preventDefault(); return; }
  dragSource = { type, idx, cardIdx };
  e.dataTransfer.effectAllowed = "move";
  e.dataTransfer.setData("text/plain", JSON.stringify(dragSource));
  setTimeout(()=>e.target.classList.add('dragging'), 0);
}
function handleDragEnd(e){
  e.target.classList.remove('dragging');
  document.querySelectorAll('.drag-over').forEach(el=>el.classList.remove('drag-over'));
  dragSource = null;
}
function handleDragOver(e){ e.preventDefault(); e.dataTransfer.dropEffect = "move"; }
function handleDragEnter(e){ e.currentTarget.classList.add('drag-over'); }
function handleDragLeave(e){ e.currentTarget.classList.remove('drag-over'); }
function handleDrop(e, targetType, targetIdx){
  e.preventDefault();
  document.querySelectorAll('.drag-over').forEach(el=>el.classList.remove('drag-over'));
  if(!dragSource) return;
  commitMove(targetType, targetIdx);
}

function handleTouchStart(e, type, idx, cardIdx){
  clearHints();
  if(type === 'pile' && !tableau[idx][cardIdx].faceUp) return;
  const touch = e.touches[0];
  touchStartCoords = {x: touch.clientX, y: touch.clientY};
  isDragGesture = false;
  dragSource = { type, idx, cardIdx };
  touchOriginalEl = e.target.closest('.card');
}
function handleTouchMove(e){
  if(!dragSource) return;
  const touch = e.touches[0];
  const dist = Math.sqrt(Math.pow(touch.clientX - touchStartCoords.x, 2) + Math.pow(touch.clientY - touchStartCoords.y, 2));
  if(dist > 10 && !isDragGesture){
    isDragGesture = true;
    const original = touchOriginalEl || e.target.closest('.card');
    if(original){
        const rect = original.getBoundingClientRect();
        touchClone.innerHTML = original.innerHTML;
        touchClone.className = "card";
        touchClone.style.width = rect.width + "px";
        touchClone.style.height = rect.height + "px";
        touchClone.style.color = original.style.color;
        touchClone.style.background = original.style.background;
        touchClone.style.display = "block";
        original.classList.add('dragging');
    }
  }
  if(isDragGesture){
     e.preventDefault();
     touchClone.style.left = (touch.clientX - 20) + "px";
     touchClone.style.top = (touch.clientY - 20) + "px";
  }
}
function handleTouchEnd(e){
  if(!dragSource) return;
  if(isDragGesture){
    e.preventDefault();
    const original = touchOriginalEl;
    if(original) original.classList.remove('dragging');
    touchClone.style.display = 'none';
    const touch = e.changedTouches[0];
    const elBelow = document.elementFromPoint(touch.clientX, touch.clientY);
    let target = elBelow ? elBelow.closest('.pile, .foundation, .hand-slot') : null;
    if(target){
      let tType = target.classList.contains('pile') ? 'pile' : (target.classList.contains('foundation') ? 'foundation' : 'hand');
      let tIdx = parseInt(target.dataset.id);
      commitMove(tType, tIdx);
    } else render();
  } else {
    e.preventDefault();
    const now = Date.now();
    const isDoubleTap =
      lastTap.type === dragSource.type &&
      lastTap.idx === dragSource.idx &&
      lastTap.cardIdx === dragSource.cardIdx &&
      (now - lastTap.ts) <= DOUBLE_TAP_WINDOW_MS;

    if(pendingTapClick !== null){
      clearTimeout(pendingTapClick);
      pendingTapClick = null;
    }

    if(isDoubleTap){
      if(doubleClickToFoundationEnabled && tryAutoMoveFromTap(dragSource.type, dragSource.idx, dragSource.cardIdx)){
        selected = null;
        render();
        checkGameState();
      } else {
        cardClick(dragSource.type, dragSource.idx, dragSource.cardIdx);
      }
      lastTap = { ts: 0, type: null, idx: null, cardIdx: null };
    } else {
      const sourceSnapshot = { ...dragSource };
      pendingTapClick = setTimeout(() => {
        pendingTapClick = null;
        cardClick(sourceSnapshot.type, sourceSnapshot.idx, sourceSnapshot.cardIdx);
      }, SINGLE_TAP_DELAY_MS);
      lastTap = { ts: now, type: dragSource.type, idx: dragSource.idx, cardIdx: dragSource.cardIdx };
    }
  }
  dragSource = null;
  isDragGesture = false;
  touchOriginalEl = null;
}

function commitMove(targetType, targetIdx){
  let success = false;
  if(targetType === 'pile'){
    if(dragSource.type === 'pile') success = executePileToPile(dragSource.idx, dragSource.cardIdx, targetIdx);
    else if(dragSource.type === 'hand') success = executeHandToPile(dragSource.idx, targetIdx);
  } else if(targetType === 'hand'){
    if(dragSource.type === 'pile' && dragSource.cardIdx === tableau[dragSource.idx].length-1)
      success = executePileToHand(dragSource.idx, targetIdx);
  } else if(targetType === 'foundation'){
     let c;
     if(dragSource.type==='pile'){
       if(dragSource.cardIdx !== tableau[dragSource.idx].length-1) return;
       c = tableau[dragSource.idx][dragSource.cardIdx];
     } else c = hand[dragSource.idx];
     if(canFoundation(c, foundations[targetIdx])){
        save(); moveCount++; foundations[targetIdx].push(c);
        if(dragSource.type==='pile'){ tableau[dragSource.idx].pop(); flipTop(dragSource.idx); }
        else hand[dragSource.idx]=null;
        persistGameState();
        success = true;
     }
  }
  if(success) { render(); checkGameState(); } else render();
}

function cardClick(type, idx, cardIdx){
  clearHints();
  if(selected){
    let success=false;
    if(type==='foundation'){
       let c;
       if(selected.type==='pile'){
         if(selected.cardIdx !== tableau[selected.idx].length-1) { selected=null; render(); return; }
         c = tableau[selected.idx][selected.cardIdx];
       } else {
         c = hand[selected.idx];
       }
       if(canFoundation(c, foundations[idx])){
         save(); moveCount++; foundations[idx].push(c);
         if(selected.type==='pile'){ tableau[selected.idx].pop(); flipTop(selected.idx); }
         else hand[selected.idx]=null;
         persistGameState();
         success=true;
       }
    } 
    else if(type==='pile') {
       if(selected.type==='pile') success=executePileToPile(selected.idx, selected.cardIdx, idx);
       else success=executeHandToPile(selected.idx, idx);
    } else if(type==='hand'){
       if(selected.type==='pile' && selected.cardIdx === tableau[selected.idx].length-1) 
         success=executePileToHand(selected.idx, idx);
    }
    
    if(success) { selected=null; render(); checkGameState(); return; }
    else {
        if(type==='pile' && !tableau[idx][cardIdx].faceUp){ selected=null; render(); return; }
    }
  }
  
  if(type==='pile'){
    if(!tableau[idx][cardIdx].faceUp) return;
    if(selected && selected.type==='pile' && selected.idx===idx && selected.cardIdx===cardIdx) selected=null;
    else selected = {type:'pile', idx, cardIdx};
  } else if (type==='hand'){
    if(!hand[idx]) return;
    if(selected && selected.type==='hand' && selected.idx===idx) selected=null;
    else selected = {type:'hand', idx};
  }
  render();
}

function createCardEl(c, type, idx, cardIdx){
  const el = document.createElement("div");
  let clickTimeoutId = null;
  el.className = "card";
  if(!c.faceUp){ el.classList.add("back"); return el; }
  el.classList.add("face");
  const sc = suitClass[c.suit];
  if(sc) el.classList.add(`suit-${sc}`);
  el.dataset.suitglyph = c.suit;
  el.style.color = suitColors[c.suit];
  if(selected && selected.type===type && selected.idx===idx){
    if(type==='hand' || (type==='pile' && cardIdx >= selected.cardIdx)) el.classList.add('selected');
  }
  el.draggable = true;
  el.ondragstart = (e) => handleDragStart(e, type, idx, cardIdx);
  el.ondragend = handleDragEnd;
  el.ontouchstart = (e) => handleTouchStart(e, type, idx, cardIdx);
  el.ontouchmove = handleTouchMove;
  el.ontouchend = handleTouchEnd;
  el.onclick = (e) => {
    e.stopPropagation();
    if(clickTimeoutId !== null) return;
    clickTimeoutId = setTimeout(() => {
      clickTimeoutId = null;
      cardClick(type, idx, cardIdx);
    }, 250);
  };
  el.ondblclick = (e) => {
    e.stopPropagation();
    if(clickTimeoutId !== null){
      clearTimeout(clickTimeoutId);
      clickTimeoutId = null;
    }
    if(!doubleClickToFoundationEnabled) return;
    if(tryAutoMoveFromTap(type, idx, cardIdx)){
      selected = null;
      render();
      checkGameState();
    }
  };
  el.innerHTML = `<div class="val-tl">${c.rank}</div><div class="suit-tr">${c.suit}</div><div class="val-center">${c.rank}</div>`;
  return el;
}

function render(){
  updateRunStatsUI();
  const computedStyle = getComputedStyle(document.documentElement);
  let gapStr = computedStyle.getPropertyValue('--stack-gap').trim();
  let gap = parseInt(gapStr); if(isNaN(gap)) gap = 24;

  document.querySelectorAll('.hand-slot').forEach(slot => {
    slot.innerHTML = "";
    const i = parseInt(slot.dataset.id);
    const isActiveSlot = i < hand.length;
    slot.style.display = isActiveSlot ? '' : 'none';
    if(!isActiveSlot) return;
    slot.ondragover = handleDragOver; slot.ondragenter = handleDragEnter;
    slot.ondragleave = handleDragLeave; slot.ondrop = (e) => handleDrop(e, 'hand', i);
    slot.onclick = () => cardClick('hand', i);
    if(hand[i]) slot.appendChild(createCardEl(hand[i], 'hand', i));
  });
  document.querySelectorAll('.foundation').forEach(found => {
    found.innerHTML = "";
    const i = parseInt(found.dataset.id);
    found.ondragover = handleDragOver; found.ondragenter = handleDragEnter;
    found.ondragleave = handleDragLeave; found.ondrop = (e) => handleDrop(e, 'foundation', i);
    found.onclick = () => cardClick('foundation', i);
    const p = foundations[i];
    if(p.length){
      const el = createCardEl(p[p.length-1], 'foundation', i, p.length-1);
      el.draggable = false; el.onclick = null; el.ontouchstart=null;
      found.appendChild(el);
    }
  });
  document.querySelectorAll('.pile').forEach(pile => {
    pile.innerHTML = "";
    const i = parseInt(pile.dataset.id);
    pile.ondragover = handleDragOver; pile.ondragenter = handleDragEnter;
    pile.ondragleave = handleDragLeave; pile.ondrop = (e) => handleDrop(e, 'pile', i);
    pile.onclick = () => { if(selected) { 
        if(selected.type==='pile') executePileToPile(selected.idx, selected.cardIdx, i);
        else executeHandToPile(selected.idx, i);
        selected=null; render();
    }};
    const stack = tableau[i];
    let ch = parseInt(computedStyle.getPropertyValue('--card-h').trim()) || 116;
    pile.style.height = (ch + (stack.length-1)*gap) + "px";
    stack.forEach((c, j) => {
      const el = createCardEl(c, 'pile', i, j);
      el.style.top = (j * gap) + "px";
      pile.appendChild(el);
    });
  });
}

function fit(){
  const app = document.querySelector('.app'); if(!app) return;

  // Available space (account for header + safe areas already in CSS heights)
  const availW = app.clientWidth;
  // Track actual header height (it can wrap on mobile) so the play area never hides behind it.
  const headerEl = document.querySelector('header');
  if(headerEl){
    const hh = Math.ceil(headerEl.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--header-h', hh + "px");
  }

  // "Design" dimensions (desktop-ish baseline), then scale down as needed.
  const baseW = 84;            // card width
  const baseH = baseW * 1.45;  // card height ratio
  const baseGap = 24;          // stack gap
  const baseColGap = 8;        // column gap
  const topRowGap = 4;         // .foundations-row/.hand-row gap
  const topSectionGap = 12;    // .top-section gap between zone groups
  const cardBorder = 2;        // rough border allowance

  const needW = (W, CG) => 7*(W + cardBorder) + 6*CG;
  const currentConfig = getCurrentDealConfig();
  const foundationSlots = 4;
  const freeCellSlots = currentConfig.freeCells;

  const foundationNeedW = foundationSlots * (baseW + cardBorder) + Math.max(0, foundationSlots - 1) * topRowGap;
  const handNeedW = freeCellSlots > 0
    ? freeCellSlots * (baseW + cardBorder) + Math.max(0, freeCellSlots - 1) * topRowGap
    : 0;
  const topSectionNeedW = foundationNeedW + handNeedW + (freeCellSlots > 0 ? topSectionGap : 0);

  // Compute a scale factor based on width so the tableau still fits horizontally.
  const tableauNeedW = needW(baseW, baseColGap);
  const targetNeedW = Math.max(tableauNeedW, topSectionNeedW);

  // Avoid division by zero in pathological cases.
  const sW = targetNeedW ? (availW / targetNeedW) : 1;
  const s = Math.min(1, sW);

  // Clamp for usability (phone → desktop).
  const w = Math.round(Math.min(120, Math.max(34, baseW * s)));
  const h = Math.round(w * 1.45);
  let g = Math.round(Math.min(36, Math.max(14, baseGap * s)));
  // Extra vertical separation on narrow screens so ranks/suits remain readable.
  if (window.innerWidth <= 520) {
    g = Math.round(Math.min(44, Math.max(18, baseGap * s * 1.25)));
  }
  // Big Corner Glyphs need additional overlap clearance.
  if(document.body.classList.contains('suit-style-corners') || document.body.classList.contains('suit-style-cb-corners')){
    g = Math.round(Math.min(52, g * 1.35));
  }
  const cg = Math.round(Math.min(12, Math.max(2, baseColGap * s)));

  document.documentElement.style.setProperty('--card-w', w + "px");
  document.documentElement.style.setProperty('--card-h', h + "px");
  document.documentElement.style.setProperty('--stack-gap', g + "px");
  document.documentElement.style.setProperty('--col-gap', cg + "px");
}


let fitRaf = 0;
function scheduleFit(){
  if(fitRaf) return;
  fitRaf = requestAnimationFrame(() => {
    fitRaf = 0;
    fit();
    render();
  });
}
document.getElementById("undoBtn").onclick = undo;
document.getElementById("autoBtn").onclick = autoPlay;
document.getElementById("giveUpBtn").onclick = () => {
  if(hasActiveRunToRecordAsLoss() && !runResultRecorded) recordGameResult('loss');
  document.getElementById('modalLose').classList.add('active');
};
document.getElementById("statsBtn").onclick = () => {
  renderStatsModal();
  document.getElementById('modalStats').classList.add('active');
};
document.getElementById("closeStatsBtn").onclick = () => document.getElementById('modalStats').classList.remove('active');
document.getElementById("resetStatsBtn").onclick = () => {
  saveStatsHistory([]);
  renderStatsModal();
};
window.addEventListener('resize', scheduleFit, {passive:true});
window.addEventListener('orientationchange', scheduleFit, {passive:true});
if(window.visualViewport){
  visualViewport.addEventListener('resize', scheduleFit, {passive:true});
  visualViewport.addEventListener('scroll', scheduleFit, {passive:true});
}
// Re-fit if the app container changes size (e.g., address bar show/hide)
try {
  const ro = new ResizeObserver(() => scheduleFit());
  ro.observe(document.body);
} catch(e) {}

loadDealVariantPreference();
applyDealVariant(currentDealVariantKey);

if(loadPersistedGameState()){
  startTimer();
  fit();
  render();
} else {
  start();
}
renderStatsModal();

initSuitStyleUI();
initDoubleClickFoundationUI();
initDealVariantUI();
renderAppVersion();
const headerEl = document.querySelector('header');
const menuToggleBtn = document.getElementById('menuToggle');
const headerControlsEl = document.getElementById('headerControls');
const mobileMenuQuery = window.matchMedia('(max-width: 520px)');

function syncMenuAccessibility(){
  if(!headerEl || !menuToggleBtn || !headerControlsEl) return;
  const isOpen = headerEl.classList.contains('menu-open');
  const shouldHideControls = mobileMenuQuery.matches && !isOpen;
  headerControlsEl.toggleAttribute('inert', shouldHideControls);
  headerControlsEl.setAttribute('aria-hidden', String(shouldHideControls));
  menuToggleBtn.setAttribute('aria-expanded', String(isOpen));
  menuToggleBtn.setAttribute('aria-label', isOpen ? 'Close menu' : 'Open menu');
}

function setMenuOpen(isOpen){
  if(!headerEl || !menuToggleBtn || !headerControlsEl) return;
  const wasOpen = headerEl.classList.contains('menu-open');
  headerEl.classList.toggle('menu-open', isOpen);
  syncMenuAccessibility();
  if(wasOpen !== isOpen){
    scheduleFit();
  }
}

function syncMenuForViewport(){
  if(!headerEl || !menuToggleBtn || !headerControlsEl) return;
  setMenuOpen(!mobileMenuQuery.matches);
}

if(menuToggleBtn){
  menuToggleBtn.addEventListener('click', () => {
    setMenuOpen(!headerEl.classList.contains('menu-open'));
  });
}

document.addEventListener('keydown', (event) => {
  if(event.key !== 'Escape' || !mobileMenuQuery.matches || !headerEl?.classList.contains('menu-open')) return;
  setMenuOpen(false);
  menuToggleBtn?.focus();
});

['autoBtn', 'giveUpBtn'].forEach((id) => {
  const actionBtn = document.getElementById(id);
  if(!actionBtn) return;
  actionBtn.addEventListener('click', () => {
    if(mobileMenuQuery.matches){
      setMenuOpen(false);
    }
  });
});

syncMenuForViewport();
mobileMenuQuery.addEventListener('change', syncMenuForViewport);

window.addEventListener('focus', syncTimerPresence);
window.addEventListener('blur', syncTimerPresence);
document.addEventListener('visibilitychange', syncTimerPresence);

// Rules modal behavior
document.addEventListener('DOMContentLoaded', () => {
  const rulesBtn = document.getElementById('rulesBtn');
  const modal = document.getElementById('rulesModal');
  const closeBtn = document.getElementById('closeRulesBtn');

  if(rulesBtn && modal){
    rulesBtn.addEventListener('click', () => modal.classList.remove('hidden'));
  }
  if(closeBtn && modal){
    closeBtn.addEventListener('click', () => modal.classList.add('hidden'));
  }
  if(modal){
    modal.addEventListener('click', (e) => {
      if(e.target === modal) modal.classList.add('hidden');
    });
  }
});

</script>

<!-- Rules Modal -->
<div id="rulesModal" class="rules-modal hidden">
  <div class="rules-content">
    
    <h2>How to Play</h2>

    <h3>Objective</h3>
    <p>Move all cards to the <b>foundations</b>, building each suit in ascending order from <b>Ace to King</b>.</p>

    <h3>Tableau Rules</h3>
    <p>The tableau columns are your working area.</p>
    <ul>
      <li>You may select <b>any face-up card</b> in a column.</li>
      <li>When you move a card, <b>every card stacked on top of it must move with it.</b></li>
      <li>Only the card you selected must be valid for its destination. The cards above it are not checked.</li>
    </ul>

    <p><b>Example</b></p>
    <p>K<span class="suit-black">♠</span><br>9<span class="suit-red">♥</span> &larr; selected<br>7<span class="suit-red">♦</span><br>3<span class="suit-black">♣</span><br>2<span class="suit-black">♣</span></p>
    <p>Selecting <b>9<span class="suit-red">♥</span></b> moves:</p>
    <p>9<span class="suit-red">♥</span><br>7<span class="suit-red">♦</span><br>3<span class="suit-black">♣</span><br>2<span class="suit-black">♣</span></p>
    <p>Only <b>9<span class="suit-red">♥</span></b> must legally fit where you place it.</p>

    <h3>Building on the Tableau</h3>
    <p>Cards must follow the game’s build rule (e.g., descending by suit).</p>
    <p>Empty columns may only be filled with a <b>King</b>.</p>

    <h3>Foundations</h3>
    <ul>
      <li>Start with an <b>Ace</b>.</li>
      <li>Build upward by suit: Ace → 2 → 3 → … → King.</li>
      <li>Cards placed in the foundation cannot return.</li>
    </ul>

    <h3>Cells</h3>
    <p>Cells are single-card holding spaces.</p>
    <ul>
      <li>One card per cell.</li>
      <li>Only the <b>top card</b> of a column may be moved into a cell.</li>
      <li>Cards in cells may later move to the tableau or foundation if legal.</li>
    </ul>
    <p>Cells allow you to temporarily free blocked cards and create new options.</p>

    <button id="closeRulesBtn">Close</button>
  </div>
</div>

</body>
</html>
